{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"],"fields":{"title":{"boost":1000.0},"text":{"boost":1.0},"tags":{"boost":1000000.0}}},"docs":[{"location":"","title":"orm-loader","text":"<p>A lightweight, reusable foundation for building and validating SQLAlchemy-based data models.</p> <p><code>orm-loader</code> provides infrastructure, not semantics.</p> <p>It focuses on:</p> <ul> <li>ORM table introspection</li> <li>safe bulk ingestion patterns</li> <li>file-based loading via staging tables</li> <li>model-agnostic validation scaffolding</li> <li>database-portable operational helpers</li> </ul> <p>No domain logic is included. No schema assumptions are enforced.</p>"},{"location":"#core-concepts","title":"Core Concepts","text":"<ul> <li>Tables are structural \u2014 semantics live downstream</li> <li>Mixins define capabilities, not behaviour contracts</li> <li>Protocols decouple infrastructure from implementations</li> <li>Ingestion is explicit and staged</li> </ul>"},{"location":"#api-reference","title":"API Reference","text":"<ul> <li>Tables</li> <li>Registry &amp; Validation</li> <li>Loaders</li> </ul>"},{"location":"#design-philosophy","title":"Design Philosophy","text":"<p><code>orm-loader</code> is intentionally conservative.</p> <p>It provides:</p> <ul> <li>mechanisms, not policies</li> <li>capabilities, not workflows</li> <li>structure, not semantics</li> </ul> <p>The library is designed to sit below:</p> <ul> <li>OMOP CDM (initial scope)</li> <li>extension to O3, MCODE, etc.</li> <li>custom clinical schemas</li> <li>research data marts</li> </ul> <p>and above:</p> <ul> <li>raw SQLAlchemy</li> <li>database-specific ingestion scripts</li> </ul>"},{"location":"#what-this-library-does-not-do","title":"What this library does not do","text":"<ul> <li>No domain validation</li> <li>No schema enforcement</li> <li>No migrations</li> <li>No concurrency guarantees</li> </ul>"},{"location":"#why-mixins-and-protocols","title":"Why mixins and protocols?","text":"<p>Mixins provide reusable behaviour.</p> <p>Protocols provide: - static typing - runtime structural checks - decoupling between infrastructure and models</p> <p>This allows downstream libraries to: - replace base classes - mock implementations - incrementally adopt features</p>"},{"location":"loaders/","title":"Loaders","text":"<p>The <code>orm_loader.loaders</code> module provides conservative, schema-aware file ingestion infrastructure for loading external data into ORM-backed staging tables.</p> <p>This subsystem is designed to handle:</p> <ul> <li>untrusted or messy source files</li> <li>large datasets requiring chunked processing</li> <li>incremental and repeatable loads</li> <li>dialect-specific optimisations (e.g. PostgreSQL COPY)</li> <li>explicit, inspectable failure modes</li> </ul> <p>Loaders are intentionally infrastructure-only: they do not embed domain rules or business semantics.</p>"},{"location":"loaders/#core-concepts","title":"Core concepts","text":""},{"location":"loaders/#loadercontext","title":"LoaderContext","text":"<p><code>LoaderContext</code></p> <p>A <code>LoaderContext</code> object carries all state required to load a single file:</p> <ul> <li>target ORM table</li> <li>database session</li> <li>staging table</li> <li>file path</li> <li>operational flags (chunking, deduplication, normalisation)</li> </ul> <p>This makes loader behaviour explicit, testable, and side-effect free.</p>"},{"location":"loaders/#loaderinterface","title":"LoaderInterface","text":"<p><code>LoaderInterface</code></p> <p>All loaders implement a common interface:</p> <ul> <li><code>orm_file_load(ctx)</code> \u2014 orchestrates file ingestion</li> <li><code>dedupe(data, ctx)</code> \u2014 defines deduplication semantics</li> </ul> <p>Concrete implementations differ only in how data is read and processed, not in how it is staged.</p>"},{"location":"loaders/#staging-tables","title":"Staging tables","text":"<p>Loaders always write to staging tables, never directly to production tables.</p> <p>This allows:</p> <ul> <li>safe rollback</li> <li>repeatable merges</li> <li>database-level deduplication</li> <li>bulk loading optimisations</li> </ul> <p>Final merge semantics are handled by the table mixins, not by loaders.</p>"},{"location":"loaders/#provided-loaders","title":"Provided loaders","text":"Loader Use case <code>PandasLoader</code> Flexible, debuggable CSV ingestion <code>ParquetLoader</code> High-volume, columnar ingestion <p>Both loaders share the same lifecycle and guarantees.</p>"},{"location":"loaders/#loader-lifecycle","title":"Loader lifecycle","text":"<ol> <li>Detect file format and encoding  </li> <li>Read data in chunks or batches  </li> <li>Optionally normalise to ORM column types  </li> <li>Optionally deduplicate (internal and/or database-level)  </li> <li>Insert into staging table  </li> <li>Return row count  </li> </ol> <p>No implicit commits or merges occur at this layer.</p>"},{"location":"loaders/#guarantees","title":"Guarantees","text":"<p>The loaders subsystem guarantees:</p> <ul> <li>deterministic ingestion behaviour</li> <li>no silent data loss</li> <li>explicit logging of dropped or malformed rows</li> <li>isolation from domain-specific rules</li> </ul> <p>It does not guarantee correctness of the source data.</p> <p><code>Helpers</code></p>"},{"location":"loaders/context/","title":"Loader Context and Diagnostics","text":"<p>This page documents the shared data structures used by the loaders subsystem.</p>"},{"location":"loaders/context/#loadercontext","title":"LoaderContext","text":"<p><code>LoaderContext</code> is an immutable coordination object passed through all loader operations.</p> <p>It encapsulates all state required to load a file without relying on globals or implicit configuration.</p>"},{"location":"loaders/context/#fields","title":"Fields","text":"Field Description <code>tableclass</code> Target ORM table class <code>session</code> Active SQLAlchemy session <code>path</code> Path to the input file <code>staging_table</code> SQLAlchemy Table used for staging <code>chunksize</code> Optional chunk size <code>normalise</code> Whether to cast values to ORM types <code>dedupe</code> Whether to deduplicate incoming data <p>Immutable context object passed through loader operations.</p> <p>The LoaderContext encapsulates all state required to load a file into a staging table, without relying on global variables.</p> <p>Attributes:</p> Name Type Description <code>tableclass</code> <code>Type[CSVTableProtocol]</code> <p>ORM table class being loaded.</p> <code>session</code> <code>Session</code> <p>Active SQLAlchemy session.</p> <code>path</code> <code>Path</code> <p>Path to the source data file.</p> <code>staging_table</code> <code>Table</code> <p>SQLAlchemy Table object representing the staging table.</p> <code>chunksize</code> <code>int | None</code> <p>Optional chunk size for incremental loading.</p> <code>normalise</code> <code>bool</code> <p>Whether to apply type casting / normalisation.</p> <code>dedupe</code> <code>bool</code> <p>Whether to perform deduplication (pre-insertion for source issues)</p>"},{"location":"loaders/context/#casting-statistics","title":"Casting statistics","text":"<p>Loaders track casting failures during normalisation to support debugging and auditability.</p>"},{"location":"loaders/context/#columncastingstats","title":"ColumnCastingStats","text":"<p>Tracks casting failures for a single column:</p> <ul> <li>total failure count</li> <li>representative example values</li> </ul>"},{"location":"loaders/context/#tablecastingstats","title":"TableCastingStats","text":"<p>Aggregates column-level statistics for a table.</p> <p>This enables loaders to emit warnings such as:</p> <ul> <li>unexpected nulls in required columns</li> <li>values that could not be cast to target types</li> </ul> <p>Statistics are logged, not raised as exceptions.</p> <p>Casting statistics for a single column.</p> <p>Aggregated casting statistics for a table, keyed by column.</p>"},{"location":"loaders/context/#orm_loader.loaders.data_classes.TableCastingStats.total_failures","title":"<code>total_failures</code>  <code>property</code>","text":"<p>Total number of casting failures.</p>"},{"location":"loaders/context/#orm_loader.loaders.data_classes.TableCastingStats.has_failures","title":"<code>has_failures()</code>","text":"<p>Whether any casting failures occurred.</p>"},{"location":"loaders/context/#orm_loader.loaders.data_classes.TableCastingStats.record","title":"<code>record(*, column, value, example_limit=3)</code>","text":"<p>Record a casting failure for a column.</p>"},{"location":"loaders/context/#orm_loader.loaders.data_classes.TableCastingStats.to_dict","title":"<code>to_dict()</code>","text":"<p>Return a dictionary representation of casting statistics.</p>"},{"location":"loaders/context/#design-notes","title":"Design notes","text":"<ul> <li>Casting failures do not abort loads</li> <li>Rows violating required constraints are dropped explicitly</li> <li>Examples are capped to avoid log flooding</li> </ul> <p>This design favours observability over strict enforcement.</p>"},{"location":"loaders/helpers/","title":"Loader Helper Utilities","text":"<p>This page documents low-level helper functions used by loaders.</p> <p>These utilities are stateless and intentionally conservative.</p>"},{"location":"loaders/helpers/#encoding-and-delimiter-detection","title":"Encoding and delimiter detection","text":""},{"location":"loaders/helpers/#infer_encodingpath","title":"<code>infer_encoding(path)</code>","text":"<p>Detects file encoding using <code>chardet</code>.</p> <ul> <li>ASCII is normalised to UTF-8</li> <li>Only a small prefix of the file is inspected</li> </ul>"},{"location":"loaders/helpers/#infer_delimpath","title":"<code>infer_delim(path)</code>","text":"<p>Detects CSV delimiter by inspecting the first line.</p> <ul> <li>Prefers tabs over commas if more frequent</li> </ul>"},{"location":"loaders/helpers/#duplicate-detection-pyarrow","title":"Duplicate detection (PyArrow)","text":""},{"location":"loaders/helpers/#arrow_drop_duplicatestable-pk_names","title":"<code>arrow_drop_duplicates(table, pk_names)</code>","text":"<p>Removes duplicate rows from a PyArrow table based on primary key columns.</p> <ul> <li>Sorts by PKs</li> <li>Keeps the first occurrence</li> <li>Handles chunked arrays safely</li> </ul> <p>Used by <code>ParquetLoader</code> for internal deduplication.</p>"},{"location":"loaders/helpers/#conservative-csv-parsing","title":"Conservative CSV parsing","text":""},{"location":"loaders/helpers/#conservative_load_parquet","title":"<code>conservative_load_parquet(...)</code>","text":"<p>Reads CSV files using PyArrow with:</p> <ul> <li>strict column inclusion</li> <li>malformed row skipping</li> <li>chunked batch iteration</li> </ul> <p>This is used when loading CSVs via the Parquet pipeline.</p>"},{"location":"loaders/helpers/#postgresql-fast-path-loading","title":"PostgreSQL fast-path loading","text":""},{"location":"loaders/helpers/#quick_load_pg","title":"<code>quick_load_pg(...)</code>","text":"<p>Loads CSV files into PostgreSQL staging tables using <code>COPY</code>.</p>"},{"location":"loaders/helpers/#characteristics","title":"Characteristics","text":"<ul> <li>Extremely fast</li> <li>Bypasses ORM</li> <li>Sensitive to data quality issues</li> </ul>"},{"location":"loaders/helpers/#failure-handling","title":"Failure handling","text":"<ul> <li>Errors trigger rollback</li> <li>Loader falls back to ORM-based loading</li> <li>No partial silent loads</li> </ul> <p>This helper is only used when explicitly supported by the database.</p>"},{"location":"loaders/loaders/","title":"Loader Implementations","text":"<p>This page documents the concrete loader implementations provided by <code>orm_loader</code>.</p> <p>All loaders implement the same interface and differ only in how data is read and processed.</p>"},{"location":"loaders/loaders/#loaderinterface","title":"LoaderInterface","text":"<p><code>LoaderInterface</code> defines the contract for all loaders.</p>"},{"location":"loaders/loaders/#required-methods","title":"Required methods","text":"<ul> <li><code>orm_file_load(ctx)</code></li> <li><code>dedupe(data, ctx)</code></li> </ul>"},{"location":"loaders/loaders/#shared-behaviour","title":"Shared behaviour","text":"<p>All loaders:</p> <ul> <li>load into staging tables only</li> <li>respect <code>LoaderContext</code> flags</li> <li>return row counts</li> <li>avoid implicit commits</li> </ul>"},{"location":"loaders/loaders/#pandasloader","title":"PandasLoader","text":"<p><code>PandasLoader</code> uses pandas to read and process files.</p>"},{"location":"loaders/loaders/#characteristics","title":"Characteristics","text":"<ul> <li>Supports CSV and TSV inputs</li> <li>Easy to debug and inspect</li> <li>Supports chunked loading</li> <li>Flexible transformation pipeline</li> </ul>"},{"location":"loaders/loaders/#trade-offs","title":"Trade-offs","text":"<ul> <li>Slower for very large datasets</li> <li>Higher memory overhead than columnar approaches</li> </ul>"},{"location":"loaders/loaders/#best-suited-for","title":"Best suited for","text":"<ul> <li>initial data exploration</li> <li>messy or inconsistent files</li> <li>pipelines requiring heavy cleaning or inspection</li> </ul>"},{"location":"loaders/loaders/#parquetloader","title":"ParquetLoader","text":"<p><code>ParquetLoader</code> uses PyArrow for columnar ingestion.</p>"},{"location":"loaders/loaders/#characteristics_1","title":"Characteristics","text":"<ul> <li>Efficient for very large datasets</li> <li>Supports Parquet and CSV inputs</li> <li>Batch-oriented processing</li> <li>Lower memory overhead</li> </ul>"},{"location":"loaders/loaders/#trade-offs_1","title":"Trade-offs","text":"<ul> <li>More complex pipeline</li> <li>Less flexible row-wise transformations</li> <li>DB-level deduplication not yet implemented</li> </ul>"},{"location":"loaders/loaders/#best-suited-for_1","title":"Best suited for","text":"<ul> <li>high-volume ingestion</li> <li>repeated production loads</li> <li>columnar data sources</li> </ul>"},{"location":"loaders/loaders/#deduplication-behaviour","title":"Deduplication behaviour","text":"<p>Deduplication occurs in two phases:</p> <ol> <li> <p>Internal deduplication    Removes duplicate primary key rows within the incoming data.</p> </li> <li> <p>Database-level deduplication (optional)    Removes rows that already exist in the database.</p> </li> </ol> <p>Database-level deduplication is currently implemented for pandas-based loads.</p>"},{"location":"loaders/loaders/#normalisation-behaviour","title":"Normalisation behaviour","text":"<p>When enabled, loaders:</p> <ul> <li>cast values to ORM column types</li> <li>drop rows violating required constraints</li> <li>log casting failures with examples</li> </ul> <p>No schema changes are performed.</p>"},{"location":"registry/","title":"Model Registry &amp; Validation","text":"<p>The <code>orm_loader.registry</code> module provides model-agnostic validation infrastructure for SQLAlchemy ORM models.</p> <p>It enables: - loading external table / field specifications - registering ORM models - structural comparison between models and specs - reusable validation rules - structured validation reports</p> <p>This layer is schema-aware but domain-agnostic.</p>"},{"location":"registry/#registry","title":"Registry","text":"<ul> <li><code>ModelRegistry</code></li> <li><code>ValidationReport</code></li> <li><code>ValidationRunner</code></li> </ul>"},{"location":"registry/#model-definitions","title":"Model Definitions","text":"<ul> <li><code>TableSpec</code></li> <li><code>FieldSpec</code></li> <li><code>ModelDescriptor</code></li> </ul>"},{"location":"registry/#end-to-end-validation-example","title":"End-to-End Validation Example","text":"<p>This example demonstrates the complete validation workflow:</p> <ol> <li>Load external specifications  </li> <li>Register ORM models  </li> <li>Run validation  </li> <li>Inspect and consume validation results  </li> </ol>"},{"location":"registry/#1-inputs","title":"1. Inputs","text":""},{"location":"registry/#external-specifications","title":"External specifications","text":"<p>Validation begins with external table and field specifications (e.g. OMOP CSVs):</p> <ul> <li><code>tables.csv</code> \u2014 table-level definitions</li> <li><code>fields.csv</code> \u2014 field-level definitions</li> </ul> <p>These describe what should exist, not how it is implemented.</p>"},{"location":"registry/#orm-models","title":"ORM models","text":"<p>Assume you have SQLAlchemy ORM models defined elsewhere:</p> <pre><code>from sqlalchemy.orm import declarative_base\nfrom orm_loader.tables import ORMTableBase\n\nBase = declarative_base()\n\nclass Person(ORMTableBase, Base):\n    __tablename__ = \"person\"\n    # columns omitted for brevity\n\nclass VisitOccurrence(ORMTableBase, Base):\n    __tablename__ = \"visit_occurrence\"\n    # columns omitted for brevity\n</code></pre>"},{"location":"registry/#2-create-a-modelregistry","title":"2. Create a ModelRegistry","text":"<p>The registry is the coordination object that holds models and specs.</p> <pre><code>from orm_loader.registry import ModelRegistry\n\nregistry = ModelRegistry(\n    model_version=\"5.4\",\n    model_name=\"OMOP\"\n)\n</code></pre>"},{"location":"registry/#3-load-specifications","title":"3. Load Specifications","text":"<p>Specifications are loaded from CSV resources:</p> <p><pre><code>from importlib.resources import files\n\nspecs = files(\"my_specs_package\")\n\nregistry.load_table_specs(\n    table_csv=specs / \"tables.csv\",\n    field_csv=specs / \"fields.csv\",\n)\n</code></pre> At this point, the registry knows:</p> <ul> <li>which tables are required</li> <li>which fields belong to each table</li> <li>primary and foreign key expectations</li> </ul>"},{"location":"registry/#4-register-orm-models","title":"4. Register ORM models","text":"<p>Models can be registered explicitly:</p> <pre><code>registry.register_models([\n    Person,\n    VisitOccurrence,\n])\n</code></pre> <p>Or discovered automatically from a package:</p> <pre><code>registry.discover_models(\"my_project.models\")\n</code></pre> <p>Each model is introspected into a <code>ModelDescriptor</code>.</p>"},{"location":"registry/#5-inspect-registry-state","title":"5. Inspect Registry State","text":"<p>Before running validation, the registry can be queried:</p> <p><pre><code>registry.known_tables()\nregistry.registered_tables()\nregistry.missing_required_tables()\n</code></pre> This supports pre-flight checks and early failure in CI pipelines.</p>"},{"location":"registry/#6-define-validators","title":"6. Define Validators","text":"<p>Validators are small, composable rule objects:</p> <pre><code>from orm_loader.registry.validation import (\n    ColumnPresenceValidator,\n    ColumnNullabilityValidator,\n    PrimaryKeyValidator,\n    ForeignKeyShapeValidator,\n)\n\nvalidators = [\n    ColumnPresenceValidator(),\n    ColumnNullabilityValidator(),\n    PrimaryKeyValidator(),\n    ForeignKeyShapeValidator(),\n]\n</code></pre> <p>Each validator:</p> <ul> <li>operates on a single model</li> <li>produces structured validation issues</li> <li>is independent of execution order</li> </ul>"},{"location":"registry/#7-run-validation","title":"7. Run Validation","text":"<p>Validation is coordinated by the <code>ValidationRunner</code>:</p> <pre><code>from orm_loader.registry.validation_runner import ValidationRunner\n\nrunner = ValidationRunner(\n    validators=validators,\n    fail_fast=False,\n)\n\nreport = runner.run(registry)\n</code></pre>"},{"location":"registry/#8-consume-the-validationreport","title":"8. Consume the ValidationReport","text":""},{"location":"registry/#overall-validity","title":"Overall Validity","text":"<pre><code>report.is_valid()\n</code></pre>"},{"location":"registry/#top-level-summary","title":"Top Level Summary","text":"<pre><code>print(report.summary())\n</code></pre>"},{"location":"registry/#human-readable-report","title":"Human-readable report","text":"<pre><code>print(report.render_text_report())\n</code></pre>"},{"location":"registry/#machine-readable-output-cicd","title":"Machine-readable output (CI/CD)","text":"<pre><code>report.to_dict()\n</code></pre>"},{"location":"registry/descriptors/","title":"Model &amp; Specification Descriptors","text":"<p>Descriptor objects provide a normalised, inspectable view of both ORM models and external specifications.</p> <p>They are immutable, explicit, and independent of validation logic.</p>"},{"location":"registry/descriptors/#tablespec","title":"TableSpec","text":"<p>Represents a table-level specification loaded from an external source (e.g. OMOP CSVs).</p> <p>Table-level specification descriptor.</p> <p>Represents metadata about a table as defined in an external specification source.</p> <p>Attributes:</p> Name Type Description <code>table_name</code> <code>str</code> <p>Logical name of the table.</p> <code>schema</code> <code>str</code> <p>Schema or namespace in which the table is defined.</p> <code>is_required</code> <code>bool</code> <p>Whether the table is required by the specification.</p> <code>description</code> <code>str</code> <p>Human-readable description of the table.</p> <code>user_guidance</code> <code>Optional[str]</code> <p>Optional additional guidance for implementers.</p>"},{"location":"registry/descriptors/#fieldspec","title":"FieldSpec","text":"<p>Represents a field-level specification loaded from an external source.</p> <p>Field-level specification descriptor.</p> <p>Represents metadata about a field/column as defined in an external specification source.</p> <p>Attributes:</p> Name Type Description <code>table_name</code> <code>str</code> <p>Name of the table to which the field belongs.</p> <code>field_name</code> <code>str</code> <p>Name of the field/column.</p> <code>data_type</code> <code>str</code> <p>Declared data type in the specification.</p> <code>is_required</code> <code>bool</code> <p>Whether the field is required.</p> <code>is_primary_key</code> <code>bool</code> <p>Whether the field is part of the primary key.</p> <code>is_foreign_key</code> <code>bool</code> <p>Whether the field is a foreign key.</p> <code>fk_table</code> <code>str | None</code> <p>Referenced table name, if the field is a foreign key.</p> <code>fk_field</code> <code>str | None</code> <p>Referenced field name, if the field is a foreign key.</p>"},{"location":"registry/descriptors/#modeldescriptor","title":"ModelDescriptor","text":"<p>A derived, introspected representation of an ORM model class.</p> <p>It captures: - column objects - primary keys - foreign key relationships</p> <p>Normalised, inspectable descriptor for an ORM model class.</p> <p>This descriptor is derived from SQLAlchemy inspection and captures the structural characteristics of a mapped ORM table.</p> <p>It is used as the primary input to validation rules.</p> <p>Attributes:</p> Name Type Description <code>model_class</code> <code>Type[ORMTableProtocol]</code> <p>The ORM model class.</p> <code>table_name</code> <code>str</code> <p>The database table name.</p> <code>columns</code> <code>dict[str, Column]</code> <p>Mapping of column names to SQLAlchemy Column objects.</p> <code>primary_keys</code> <code>set[str]</code> <p>Set of primary key column names.</p> <code>foreign_keys</code> <code>dict[str, tuple[str, str]]</code> <p>Mapping of column name to referenced (table, field).</p>"},{"location":"registry/descriptors/#orm_loader.registry.registry.ModelDescriptor.cls","title":"<code>cls</code>  <code>property</code>","text":"<p>Alias for the underlying ORM model class.</p> <p>Returns:</p> Type Description <code>Type[ORMTableProtocol]</code> <p>The ORM model class.</p>"},{"location":"registry/descriptors/#orm_loader.registry.registry.ModelDescriptor.from_model","title":"<code>from_model(model)</code>  <code>classmethod</code>","text":"<p>Construct a ModelDescriptor from an ORM model class.</p> <p>Parameters:</p> Name Type Description Default <code>model</code> <code>Type[ORMTableProtocol]</code> <p>An ORM-mapped table class.</p> required <p>Returns:</p> Type Description <code>ModelDescriptor</code> <p>A descriptor derived from SQLAlchemy inspection.</p> <p>Raises:</p> Type Description <code>TypeError</code> <p>If the provided class is not a mapped ORM model.</p>"},{"location":"registry/registry/","title":"ModelRegistry","text":"<p>The <code>ModelRegistry</code> is the central coordination object for model registration and validation.</p> <p>It holds: - registered ORM models - external table specifications - external field specifications - derived model descriptors</p> <p>The registry does not perform validation itself \u2014 it provides the context required for validators and runners.</p>"},{"location":"registry/registry/#responsibilities","title":"Responsibilities","text":"<ul> <li>Load table and field specifications</li> <li>Register ORM model classes</li> <li>Track required vs implemented tables</li> <li>Provide descriptors for validation</li> </ul>"},{"location":"registry/registry/#api","title":"API","text":"<p>Holds a registry of ORM models along with their specifications.</p> <p>The registry coordinates: - loading table and field specifications - registering ORM model classes - identifying missing or required tables - providing model descriptors for validation</p> <p>Load table and field specifications from CSV files (currently only OMOP format supported). TODO: support generalised specification formats via LinkML or similar.</p> <p>Register ORM model classes and compare against specifications to confirm accurate and  complete implementation.</p> <p>Model-specific constraints can be created to extend context-specific validation such  as OMOP domain constraints, value set adherence, etc.</p> <p>Validation logic itself is implemented elsewhere and consumes the registry as contextual input.</p>"},{"location":"registry/registry/#orm_loader.registry.registry.ModelRegistry.__init__","title":"<code>__init__(*, model_version, model_name=None)</code>","text":"<p>Initialise a new model registry.</p> <p>Parameters:</p> Name Type Description Default <code>model_version</code> <code>str</code> <p>Version identifier for the model set.</p> required <code>model_name</code> <code>Optional[str]</code> <p>Optional human-readable name for the model set.</p> <code>None</code>"},{"location":"registry/registry/#orm_loader.registry.registry.ModelRegistry.discover_models","title":"<code>discover_models(package)</code>","text":"<p>Discover and register ORM models from a Python package.</p> <p>All non-abstract ORM-mapped classes found in the package and its submodules are registered.</p> <p>Parameters:</p> Name Type Description Default <code>package</code> <code>str</code> <p>Dotted import path of the package to scan.</p> required"},{"location":"registry/registry/#orm_loader.registry.registry.ModelRegistry.known_tables","title":"<code>known_tables()</code>","text":"<p>Return table names defined in the specification.</p> <p>Returns:</p> Type Description <code>set[str]</code> <p>Known table names.</p>"},{"location":"registry/registry/#orm_loader.registry.registry.ModelRegistry.load_table_specs","title":"<code>load_table_specs(*, table_csv, field_csv)</code>","text":"<p>Load table and field specifications into the registry.</p> <p>Parameters:</p> Name Type Description Default <code>table_csv</code> <p>CSV resource containing table specifications.</p> required <code>field_csv</code> <p>CSV resource containing field specifications.</p> required"},{"location":"registry/registry/#orm_loader.registry.registry.ModelRegistry.missing_required_tables","title":"<code>missing_required_tables()</code>","text":"<p>Return required tables missing from the registered models.</p> <p>Returns:</p> Type Description <code>set[str]</code> <p>Required table names that are not implemented.</p>"},{"location":"registry/registry/#orm_loader.registry.registry.ModelRegistry.models","title":"<code>models()</code>","text":"<p>Return registered models keyed by table name.</p> <p>Returns:</p> Type Description <code>dict[str, ModelDescriptor]</code> <p>Registered model descriptors.</p>"},{"location":"registry/registry/#orm_loader.registry.registry.ModelRegistry.register_model","title":"<code>register_model(model)</code>","text":"<p>Register a single ORM model class.</p> <p>Parameters:</p> Name Type Description Default <code>model</code> <code>type</code> <p>ORM-mapped table class.</p> required"},{"location":"registry/registry/#orm_loader.registry.registry.ModelRegistry.register_models","title":"<code>register_models(models)</code>","text":"<p>Register multiple ORM model classes.</p> <p>Parameters:</p> Name Type Description Default <code>models</code> <code>list[type]</code> <p>Iterable of ORM-mapped table classes.</p> required"},{"location":"registry/registry/#orm_loader.registry.registry.ModelRegistry.registered_tables","title":"<code>registered_tables()</code>","text":"<p>Return table names registered from ORM models.</p> <p>Returns:</p> Type Description <code>set[str]</code> <p>Registered table names.</p>"},{"location":"registry/validation/","title":"Validators","text":"<p>Validators implement focused, composable validation rules that compare ORM models against specifications.</p> <p>Each validator: - operates on a single model - produces structured validation issues - is independent of execution order</p>"},{"location":"registry/validation/#validator-protocol","title":"Validator Protocol","text":"<p>               Bases: <code>Protocol</code></p>"},{"location":"registry/validation/#columnnullabilityvalidator","title":"ColumnNullabilityValidator","text":"<p>Ensures required columns are not nullable.</p> <p>Ensures required columns are NOT NULL in the ORM model.</p>"},{"location":"registry/validation/#columnpresencevalidator","title":"ColumnPresenceValidator","text":"<p>Ensures all specified columns exist on the ORM model.</p> <p>Ensures all specified columns are present on the ORM model.</p>"},{"location":"registry/validation/#primarykeyvalidator","title":"PrimaryKeyValidator","text":"<p>Validates primary key presence, nullability, and alignment with specs.</p> <p>Validates primary key presence and correctness.</p> <p>Always-on: - PK must exist - PK columns must be NOT NULL</p> <p>Spec-aware (if FieldSpec provided): - Spec PKs must exist in ORM - ORM PKs should be declared in spec</p>"},{"location":"registry/validation/#foreignkeyshapevalidator","title":"ForeignKeyShapeValidator","text":"<p>Validates structural correctness of foreign key definitions.</p> <p>Validates structural correctness of foreign key definitions.</p>"},{"location":"registry/validation_report/","title":"Validation Reports","text":"<p>Validation reports provide a structured, machine-readable summary of validation outcomes.</p> <p>They are suitable for: - CLI output - CI/CD pipelines - JSON serialisation - programmatic inspection</p>"},{"location":"registry/validation_report/#validationissue","title":"ValidationIssue","text":"<p>Represents a single validation finding.</p> <p>Validation issues are immutable data records describing a deviation between an ORM model and an external specification.</p> <p>Attributes:</p> Name Type Description <code>table</code> <code>str</code> <p>Name of the table where the issue was found.</p> <code>level</code> <code>SeverityLevel</code> <p>Severity level of the issue.</p> <code>message</code> <code>str</code> <p>Machine-readable issue identifier.</p> <code>field</code> <code>Optional[str]</code> <p>Optional field/column name associated with the issue.</p> <code>expected</code> <code>Optional[str]</code> <p>Optional expected value or condition.</p> <code>actual</code> <code>Optional[str]</code> <p>Optional actual value or condition.</p> <code>hint</code> <code>Optional[str]</code> <p>Optional human-readable guidance.</p>"},{"location":"registry/validation_report/#severitylevel","title":"SeverityLevel","text":"<p>               Bases: <code>Enum</code></p>"},{"location":"registry/validation_report/#validationreport","title":"ValidationReport","text":"<p>Aggregate report of validation outcomes.</p> <p>A ValidationReport collects all issues produced during validation and provides multiple representations suitable for: - interactive inspection - text reporting - JSON serialisation - CI/CD pipeline integration</p>"},{"location":"registry/validation_report/#orm_loader.registry.validation_report.ValidationReport.__init__","title":"<code>__init__(*, model_version, model_name=None)</code>","text":"<p>Initialise a new validation report.</p> <p>Parameters:</p> Name Type Description Default <code>model_version</code> <code>str</code> <p>Version identifier for the validated model set.</p> required <code>model_name</code> <code>Optional[str]</code> <p>Optional human-readable model name.</p> <code>None</code>"},{"location":"registry/validation_report/#orm_loader.registry.validation_report.ValidationReport.add","title":"<code>add(issue)</code>","text":"<p>Add a validation issue to the report.</p> <p>Parameters:</p> Name Type Description Default <code>issue</code> <code>ValidationIssue</code> <p>Validation issue to record.</p> required"},{"location":"registry/validation_report/#orm_loader.registry.validation_report.ValidationReport.exit_code","title":"<code>exit_code()</code>","text":"<p>Return a process exit code suitable for CI/CD pipelines.</p> <p>Returns:</p> Type Description <code>int</code> <p>1 if any ERROR-level issues are present, otherwise 0.</p>"},{"location":"registry/validation_report/#orm_loader.registry.validation_report.ValidationReport.is_valid","title":"<code>is_valid()</code>","text":"<p>Return whether the report contains no issues.</p> <p>Returns:</p> Type Description <code>bool</code> <p>True if no issues are present, otherwise False.</p>"},{"location":"registry/validation_report/#orm_loader.registry.validation_report.ValidationReport.render_text_report","title":"<code>render_text_report()</code>","text":"<p>Render a human-readable multi-line text report.</p> <p>Issues are grouped by table and rendered with simple visual indicators for severity.</p> <p>Returns:</p> Type Description <code>str</code> <p>Formatted text report.</p>"},{"location":"registry/validation_report/#orm_loader.registry.validation_report.ValidationReport.summary","title":"<code>summary()</code>","text":"<p>Return a one-line human-readable summary.</p> <p>Returns:</p> Type Description <code>str</code> <p>Summary string including error, warning, and info counts.</p>"},{"location":"registry/validation_report/#orm_loader.registry.validation_report.ValidationReport.to_dict","title":"<code>to_dict()</code>","text":"<p>Return a structured dictionary representation of the report.</p> <p>Intended for use in CI/CD pipelines and programmatic consumers.</p> <p>Returns:</p> Type Description <code>dict</code> <p>Dictionary representation of the validation report.</p>"},{"location":"registry/validation_report/#orm_loader.registry.validation_report.ValidationReport.to_json","title":"<code>to_json()</code>","text":"<p>Serialise the report to a JSON string.</p> <p>Returns:</p> Type Description <code>str</code> <p>JSON-formatted validation report.</p>"},{"location":"registry/validation_runner/","title":"Validation Runner","text":"<p>The validation runner coordinates: - registered models - loaded specifications - validator execution - aggregation of validation issues</p> <p>It provides a single entry point for validating a model registry.</p>"},{"location":"registry/validation_runner/#api","title":"API","text":"<p>Coordinates execution of validators against a model registry.</p> <p>The runner itself is deliberately simple and does not embed any validation logic. All rules are provided via Validator instances.</p>"},{"location":"registry/validation_runner/#orm_loader.registry.validation_runner.ValidationRunner.__init__","title":"<code>__init__(validators, fail_fast=False)</code>","text":"<p>Initialise a validation runner.</p> <p>Parameters:</p> Name Type Description Default <code>validators</code> <code>list[Validator]</code> <p>List of validator implementations to execute.</p> required <code>fail_fast</code> <code>bool</code> <p>Whether to stop execution on the first ERROR-level issue.</p> <code>False</code>"},{"location":"registry/validation_runner/#orm_loader.registry.validation_runner.ValidationRunner.run","title":"<code>run(registry)</code>","text":"<p>Run validation across all registered models.</p> <p>Parameters:</p> Name Type Description Default <code>registry</code> <code>ModelRegistry</code> <p>Model registry containing models and specifications.</p> required <p>Returns:</p> Type Description <code>ValidationReport</code> <p>Aggregated validation report.</p>"},{"location":"tables/","title":"Table Infrastructure","text":"<p>The <code>orm_loader.tables</code> module provides foundational building blocks for defining, inspecting, serialising, and loading ORM tables.</p> <p>All components are: - model-agnostic - database-portable - safe to compose</p>"},{"location":"tables/#table-base-mixins","title":"Table Base &amp; Mixins","text":"<ul> <li><code>ORMTableBase</code></li> <li><code>SerialisableTableInterface</code></li> <li><code>CSVLoadableTableInterface</code></li> </ul>"},{"location":"tables/#supporting-utilities","title":"Supporting Utilities","text":"<ul> <li><code>IdAllocator</code></li> <li>Typing Protocols</li> <li>Materialised Views</li> </ul>"},{"location":"tables/allocators/","title":"IdAllocator","text":"<p>A simple in-process ID allocator for controlled ingestion contexts.</p> <p>Used when: - database sequences are unavailable - ingestion is single-writer - deterministic ID assignment is required</p>"},{"location":"tables/allocators/#api","title":"API","text":"<p>Simple in-process ID allocator.</p> <p>This utility provides monotonically increasing integer identifiers starting from a known baseline. It is intended for environments where database-managed sequences are unavailable or undesirable.</p> <p>Typical use cases include: - SQLite or other lightweight databases without sequences - controlled, single-writer ingestion pipelines - deterministic ID assignment during bulk loads</p> <p>This allocator is deliberately minimal and not safe for concurrent writers or multi-process use.</p>"},{"location":"tables/allocators/#orm_loader.tables.allocators.IdAllocator.reserve","title":"<code>reserve(n)</code>","text":"<p>Reserve a contiguous block of identifiers.</p> <p>This method advances the internal counter by <code>n</code> and returns a <code>range</code> representing the reserved identifiers.</p> <p>Parameters:</p> Name Type Description Default <code>n</code> <code>int</code> <p>The number of identifiers to reserve.</p> required <p>Returns:</p> Type Description <code>range</code> <p>A range covering the reserved identifiers.</p>"},{"location":"tables/loadable_table/","title":"Loadable Table Mixins","text":"<p>Infrastructure for staged, file-based ingestion into ORM tables.</p> <p>Supports: - CSV-based ingestion - optional fast-path database COPY - dialect-aware merge strategies - Parquet loading hooks</p>"},{"location":"tables/loadable_table/#csvloadabletableinterface","title":"CSVLoadableTableInterface","text":"<p>               Bases: <code>ORMTableBase</code></p> <p>Mixin for ORM tables that support staged CSV-based ingestion.</p> <p>This interface implements a database-portable ingestion workflow based on temporary staging tables. It supports: - dialect-aware staging table creation - fast-path COPY-based loading where available - ORM-based fallback loading - configurable merge strategies - explicit staging table lifecycle management</p> <p>The class is designed for controlled ingestion pipelines and does not attempt to provide concurrency guarantees.</p>"},{"location":"tables/loadable_table/#orm_loader.tables.loadable_table.CSVLoadableTableInterface.create_staging_table","title":"<code>create_staging_table(session)</code>  <code>classmethod</code>","text":"<p>Create a fresh staging table for ingestion.</p> <p>Any existing staging table with the same name is dropped first. The staging table schema mirrors the target table schema.</p> <p>Parameters:</p> Name Type Description Default <code>session</code> <code>Session</code> <p>An active SQLAlchemy session bound to an engine.</p> required <p>Raises:</p> Type Description <code>RuntimeError</code> <p>If the session is not bound to an engine.</p> <code>NotImplementedError</code> <p>If the database dialect is unsupported.</p>"},{"location":"tables/loadable_table/#orm_loader.tables.loadable_table.CSVLoadableTableInterface.csv_columns","title":"<code>csv_columns()</code>  <code>classmethod</code>","text":"<p>Return a mapping of CSV column names to model columns.</p> <p>By default this is equivalent to :meth:<code>model_columns</code>. Override this method to implement custom column mappings.</p> <p>Returns:</p> Type Description <code>dict[str, ColumnElement]</code> <p>Mapping of input column names to SQLAlchemy columns.</p>"},{"location":"tables/loadable_table/#orm_loader.tables.loadable_table.CSVLoadableTableInterface.drop_staging_table","title":"<code>drop_staging_table(session)</code>  <code>classmethod</code>","text":"<p>Drop the staging table if it exists.</p>"},{"location":"tables/loadable_table/#orm_loader.tables.loadable_table.CSVLoadableTableInterface.get_staging_table","title":"<code>get_staging_table(session)</code>  <code>classmethod</code>","text":"<p>Return the reflected staging table, creating it if necessary.</p> <p>Parameters:</p> Name Type Description Default <code>session</code> <code>Session</code> <p>An active SQLAlchemy session bound to an engine.</p> required <p>Returns:</p> Type Description <code>Table</code> <p>The reflected staging table.</p>"},{"location":"tables/loadable_table/#orm_loader.tables.loadable_table.CSVLoadableTableInterface.load_csv","title":"<code>load_csv(session, path, *, loader=None, normalise=True, dedupe=False, chunksize=None, merge_strategy='replace')</code>  <code>classmethod</code>","text":"<p>Load a CSV (or CSV-like) file into the target table.</p> <p>This method orchestrates the full staged ingestion lifecycle: - staging table creation - file loading - merge into the target table - staging table cleanup</p> <p>Parameters:</p> Name Type Description Default <code>session</code> <code>Session</code> <p>An active SQLAlchemy session.</p> required <code>path</code> <code>Path</code> <p>Path to the input CSV or Parquet file.</p> required <code>loader</code> <code>LoaderInterface | None</code> <p>Optional explicit loader instance.</p> <code>None</code> <code>normalise</code> <code>bool</code> <p>Whether to apply table-level normalisation.</p> <code>True</code> <code>dedupe</code> <code>bool</code> <p>Whether to deduplicate incoming rows.</p> <code>False</code> <code>chunksize</code> <code>int | None</code> <p>Optional chunk size for incremental loading.</p> <code>None</code> <code>merge_strategy</code> <code>str</code> <p>Merge strategy to apply (e.g. <code>replace</code> or <code>upsert</code>).</p> <code>'replace'</code> <p>Returns:</p> Type Description <code>int</code> <p>Number of rows loaded.</p>"},{"location":"tables/loadable_table/#orm_loader.tables.loadable_table.CSVLoadableTableInterface.load_staging","title":"<code>load_staging(loader, loader_context)</code>  <code>classmethod</code>","text":"<p>Load data into the staging table.</p> <p>This method attempts a fast-path database-native load where supported, falling back to an ORM-based loader if necessary.</p> <p>Parameters:</p> Name Type Description Default <code>loader</code> <code>LoaderInterface</code> <p>Loader implementation used for ORM-based loading.</p> required <code>loader_context</code> <code>LoaderContext</code> <p>Context object containing session, path, and load options.</p> required <p>Returns:</p> Type Description <code>int</code> <p>Number of rows loaded into the staging table.</p>"},{"location":"tables/loadable_table/#orm_loader.tables.loadable_table.CSVLoadableTableInterface.merge_from_staging","title":"<code>merge_from_staging(session, merge_strategy='replace')</code>  <code>classmethod</code>","text":"<p>Merge data from the staging table into the target table.</p> <p>Parameters:</p> Name Type Description Default <code>session</code> <code>Session</code> <p>An active SQLAlchemy session.</p> required <code>merge_strategy</code> <code>str</code> <p>Merge strategy to apply.</p> <code>'replace'</code>"},{"location":"tables/loadable_table/#orm_loader.tables.loadable_table.CSVLoadableTableInterface.orm_staging_load","title":"<code>orm_staging_load(loader, loader_context)</code>  <code>classmethod</code>","text":"<p>Load data into the staging table using an ORM-based loader.</p> <p>Returns:</p> Type Description <code>int</code> <p>Number of rows loaded.</p>"},{"location":"tables/loadable_table/#orm_loader.tables.loadable_table.CSVLoadableTableInterface.staging_tablename","title":"<code>staging_tablename()</code>  <code>classmethod</code>","text":"<p>Return the name of the staging table for this model.</p> <p>If a custom staging table name has been set on the class, it is used; otherwise a default name derived from <code>__tablename__</code> is returned.</p> <p>Returns:</p> Type Description <code>str</code> <p>The staging table name.</p>"},{"location":"tables/mat_view/","title":"Materialised Views","text":"<p>This module provides a SQLAlchemy-native pattern for defining, creating, refreshing, and orchestrating materialized views using normal <code>Select</code> constructs, with explicit dependency management and deterministic refresh order.</p> <p>It is designed for:</p> <ul> <li>analytics and reporting layers</li> <li>large fact tables with repeated joins or aggregates</li> <li>schema-level orchestration (migrations, setup, Airflow, admin tasks)</li> </ul> <p>The implementation is PostgreSQL-oriented (due to materialized view support), but remains cleanly isolated from ORM persistence logic.</p>"},{"location":"tables/mat_view/#overview","title":"Overview","text":"<p>The materialized view system consists of four main parts:</p> <ol> <li><code>CreateMaterializedView</code>: A custom SQLAlchemy DDLElement that compiles a Select into a <code>CREATE MATERIALIZED VIEW IF NOT EXISTS</code> statement.</li> <li><code>MaterializedViewMixin</code>: A mixin used to define materialized views declaratively, including:<ul> <li>name</li> <li>backing <code>Select</code></li> <li>optional dependencies</li> </ul> </li> <li>Dependency resolution: A topological sort over declared dependencies to determine refresh order.</li> <li>Refresh orchestration: Helpers to refresh one or many materialized views safely and predictably.</li> </ol>"},{"location":"tables/mat_view/#defining-the-materialised-view","title":"Defining the Materialised View","text":"<p>               Bases: <code>DDLElement</code></p> <p><code>CreateMaterializedView</code></p> <p>SQLAlchemy DDL element representing a CREATE MATERIALIZED VIEW statement.</p> <p>This custom DDL construct allows a SQLAlchemy Select construct to be compiled into a backend-specific CREATE MATERIALIZED VIEW statement, enabling materialized view creation to be expressed using SQLAlchemy's DDL execution model.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <p>Name of the materialized view to be created.</p> required <code>selectable</code> <p>A SQLAlchemy Select construct defining the query backing the materialized view.</p> required <p><code>MaterializedViewMixin</code></p> <p>Mixin providing materialized view lifecycle helpers.</p> <p>Classes using this mixin must define:</p> <ul> <li><code>__mv_name__</code>: the name of the materialized view</li> <li><code>__mv_select__</code>: a SQLAlchemy Select defining the view contents</li> <li>optionally, <code>__mv_dependencies__</code>: names of tables or materialized views this MV depends on</li> </ul> <p>This mixin does not define ORM mappings; it is intended for schema-level helpers used during migrations, setup, or administrative workflows.</p> <p>Examples:</p> <pre><code>class RecentObservationMV(MaterializedViewMixin):\n\n    __mv_name__ = \"mv_recent_observation\"\n\n    __mv_select__ = (\n        select(\n            Observation.observation_id,\n            Observation.person_id,\n            Observation.observation_date,\n            Observation.value_as_number,\n            Concept.concept_id,\n            Concept.concept_name,\n            Concept.domain_id,\n        )\n        .join(\n            Concept,\n            Observation.observation_concept_id == Concept.concept_id\n        )\n        .where(\n            Observation.observation_date\n            &gt;= func.current_date() - text(\"INTERVAL '30 days'\")\n        )\n    )\n</code></pre> <p><code>__mv_select__</code> is a normal SQLAlchemy Select. No special syntax required.</p> <p>By combining with declarative base, you can define columns to query the mv as an object too:</p> <p><pre><code>daily_counts_select = (\n    select(\n        Observation.observation_date.label(\"observation_date\"),\n        Observation.observation_concept_id.label(\"concept_id\"),\n        sa.func.count().label(\"n_observations\"),\n        sa.func.row_number().over().label('mv_id')\n    )\n    .group_by(\n        Observation.observation_date,\n        Observation.observation_concept_id,\n    )\n)\n\nclass DailyObservationCountsMV(Base, MaterializedViewMixin):\n\n    __mv_name__ = \"mv_daily_observation_counts\"\n    __mv_select__ = daily_counts_select\n    __mv_pk__ = [\"mv_id\"]\n    __table_args__ = {\"extend_existing\": True}\n    __tablename__ = __mv_name__\n\n    __mv_dependencies__ = {\n        \"observation\",\n        \"concept\",\n    }\n\n    mv_id = sa.Column(primary_key=True)\n    observation_date = sa.Column(sa.Date, nullable=False)\n    concept_id = sa.Column(sa.Integer, nullable=False)\n    n_observations = sa.Column(sa.Integer, nullable=False)\n</code></pre> Query like a normal mapped class:</p> <pre><code>rows = (\n    session.query(DailyObservationCount)\n    .filter(DailyObservationCount.observation_date &gt;= date(2025, 1, 1))\n    .order_by(DailyObservationCount.n_observations.desc())\n    .all()\n)\n</code></pre> <p>Best practices</p> <ul> <li>No inserts / updates</li> <li>Composite PK required for ORM identity map</li> <li>Treat as immutable cache</li> </ul> <p><code>resolve_mv_refresh_order</code></p> <p>Resolve materialized view refresh order using topological sort.</p> <p>Raises:</p> Type Description <code>RuntimeError</code> <p>If a dependency cycle is detected.</p> <p><code>refresh_all_mvs</code></p> <p>Handle refreshing multiple materialized views in dependency order.</p> <p>Examples:</p> <pre><code>    ALL_MVS = [\n        ObservationWithConceptMV,\n        DailyObservationCountsMV,\n    ]\n\n    refresh_all_mvs(engine, ALL_MVS)\n</code></pre>"},{"location":"tables/mat_view/#orm_loader.mappers.materialised_view_mixin.MaterializedViewMixin.__mv_dependencies__","title":"<code>__mv_dependencies__ = set()</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"tables/mat_view/#orm_loader.mappers.materialised_view_mixin.MaterializedViewMixin.__mv_name__","title":"<code>__mv_name__</code>  <code>instance-attribute</code>","text":""},{"location":"tables/mat_view/#orm_loader.mappers.materialised_view_mixin.MaterializedViewMixin.__mv_select__","title":"<code>__mv_select__</code>  <code>instance-attribute</code>","text":""},{"location":"tables/mat_view/#orm_loader.mappers.materialised_view_mixin.MaterializedViewMixin.create_mv","title":"<code>create_mv(bind)</code>  <code>classmethod</code>","text":"<p>Create the materialized view if it does not already exist.</p> <p>Parameters:</p> Name Type Description Default <code>bind</code> <p>A SQLAlchemy Engine or Connection used to execute the DDL.</p> required Notes <p>The underlying SQL is emitted via a custom DDL element and executed directly against the database. This operation is not transactional on all backends.</p> <p>Examples:</p> <pre><code>with engine.begin() as conn:\n    RecentObservationMV.create_mv(conn)\n</code></pre> <p>This emits SQL equivalent to:</p> <pre><code>CREATE MATERIALIZED VIEW IF NOT EXISTS mv_recent_observation AS\nSELECT\n    observation.observation_id,\n    observation.person_id,\n    observation.observation_date,\n    observation.value_as_number\nFROM observation\nWHERE observation.observation_date &gt;= CURRENT_DATE - INTERVAL '30 days';\n</code></pre>"},{"location":"tables/mat_view/#orm_loader.mappers.materialised_view_mixin.MaterializedViewMixin.refresh_mv","title":"<code>refresh_mv(bind)</code>  <code>classmethod</code>","text":"<p>Refresh the contents of the materialized view.</p> <p>Parameters:</p> Name Type Description Default <code>bind</code> <p>A SQLAlchemy Engine or Connection used to execute the refresh.</p> required Notes <p>This method issues a REFRESH MATERIALIZED VIEW statement and assumes backend support (e.g. PostgreSQL). Concurrent refresh semantics are not handled here.</p> <p>Examples:</p> <pre><code>with engine.begin() as conn:\n    RecentObservationMV.refresh_mv(conn)\n</code></pre>"},{"location":"tables/orm_table/","title":"ORMTableBase","text":"<p><code>ORMTableBase</code> is the foundational mixin for all ORM tables in <code>orm-loader</code>.</p> <p>It provides: - primary key introspection - column inspection - ID allocation helpers</p> <p>It contains no domain logic.</p> <p>This page is generated from in-code documentation.</p>"},{"location":"tables/orm_table/#api","title":"API","text":"<p>Mixin for SQLAlchemy ORM-mapped tables providing structural introspection and helper utilities.</p> <p>This base class intentionally avoids any domain or schema semantics and is designed to sit at the lowest level of a model hierarchy.</p> <p>It provides: - mapper access - primary key discovery and extraction - column inspection helpers - required-field detection for ingestion - monotonic ID allocation support</p>"},{"location":"tables/orm_table/#orm_loader.tables.orm_table.ORMTableBase.allocator","title":"<code>allocator(session)</code>  <code>classmethod</code>","text":"<p>Create an ID allocator initialised from the current table state.</p> <p>The allocator is initialised using the current maximum primary key value and can be used to generate monotonically increasing identifiers in environments without database-managed sequences.</p> <p>Used to support autoincrementing primary keys on dialects without native sequence support (e.g., SQLite).</p> <p>Parameters:</p> Name Type Description Default <code>session</code> <p>An active SQLAlchemy session.</p> required <p>Returns:</p> Type Description <code>IdAllocator</code> <p>An ID allocator initialised to the current maximum ID.</p>"},{"location":"tables/orm_table/#orm_loader.tables.orm_table.ORMTableBase.clean_kwargs","title":"<code>clean_kwargs(data, *, drop_nulls=True, strict=False)</code>  <code>classmethod</code>","text":"<p>Normalise inbound constructor kwargs: - nan / NaT / 'nan' / '' -&gt; None - optionally drop nulls - optionally validate required columns</p>"},{"location":"tables/orm_table/#orm_loader.tables.orm_table.ORMTableBase.mapper_for","title":"<code>mapper_for()</code>  <code>classmethod</code>","text":"<p>Return the SQLAlchemy mapper associated with this ORM class.</p> <p>This is a thin wrapper around <code>sqlalchemy.inspect</code> that provides a single, explicit access point for mapper inspection.</p> <p>Returns:</p> Type Description <code>Mapper</code> <p>The mapper associated with the ORM-mapped class.</p> <p>Raises:</p> Type Description <code>TypeError</code> <p>If the class is not a mapped SQLAlchemy ORM class.</p>"},{"location":"tables/orm_table/#orm_loader.tables.orm_table.ORMTableBase.max_id","title":"<code>max_id(session)</code>  <code>classmethod</code>","text":"<p>Return the maximum value of the primary key column.</p> <p>This method only supports tables with a single-column primary key.</p> <p>Parameters:</p> Name Type Description Default <code>session</code> <p>A SQLAlchemy session.</p> required <p>Returns:</p> Type Description <code>int</code> <p>The maximum primary key value, or 0 if the table is empty.</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If the table has a composite primary key.</p>"},{"location":"tables/orm_table/#orm_loader.tables.orm_table.ORMTableBase.model_columns","title":"<code>model_columns()</code>  <code>classmethod</code>","text":"<p>Return all mapped columns for the table.</p> <p>Returns:</p> Type Description <code>dict[str, ColumnElement]</code> <p>A mapping of column name to column object.</p>"},{"location":"tables/orm_table/#orm_loader.tables.orm_table.ORMTableBase.pk_columns","title":"<code>pk_columns()</code>  <code>classmethod</code>","text":"<p>Return the primary key columns for the mapped table.</p> <p>The columns are returned in mapper-defined order.</p> <p>Returns:</p> Type Description <code>list[ColumnElement]</code> <p>A list of primary key column objects.</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If the table has no primary key defined.</p>"},{"location":"tables/orm_table/#orm_loader.tables.orm_table.ORMTableBase.pk_names","title":"<code>pk_names()</code>  <code>classmethod</code>","text":"<p>Return the primary key column names.</p> <p>Returns:</p> Type Description <code>list[str]</code> <p>A list of primary key column names.</p>"},{"location":"tables/orm_table/#orm_loader.tables.orm_table.ORMTableBase.pk_tuple","title":"<code>pk_tuple(obj)</code>  <code>classmethod</code>","text":"<p>Extract primary key values from an ORM instance as a tuple.</p> <p>Values are returned in mapper-defined primary key order.</p> <p>Parameters:</p> Name Type Description Default <code>obj</code> <code>Any</code> <p>An ORM-mapped instance of this class.</p> required <p>Returns:</p> Type Description <code>tuple</code> <p>A tuple of primary key values.</p>"},{"location":"tables/orm_table/#orm_loader.tables.orm_table.ORMTableBase.pk_values","title":"<code>pk_values(obj)</code>  <code>classmethod</code>","text":"<p>Extract primary key values from an ORM instance.</p> <p>Parameters:</p> Name Type Description Default <code>obj</code> <code>Any</code> <p>An ORM-mapped instance of this class.</p> required <p>Returns:</p> Type Description <code>dict[str, Any]</code> <p>A dictionary mapping primary key column names to values.</p>"},{"location":"tables/orm_table/#orm_loader.tables.orm_table.ORMTableBase.required_columns","title":"<code>required_columns()</code>  <code>classmethod</code>","text":"<p>Return column names that must be present in inbound data.</p> <p>A column is considered required if it is: - non-nullable - has no Python-side default - has no server-side default</p> <p>This method is intended for ingestion-time validation and does not attempt to enforce schema semantics beyond insert viability.</p> <p>Returns:</p> Type Description <code>set[str]</code> <p>A set of required column names.</p>"},{"location":"tables/serialisable_table/","title":"SerialisableTableInterface","text":"<p>Mixin providing explicit, deterministic serialisation helpers for ORM row instances.</p> <p>Supports: - dictionary conversion - JSON serialisation - stable row fingerprints</p>"},{"location":"tables/serialisable_table/#api","title":"API","text":"<p>               Bases: <code>ORMTableBase</code></p> <p>Mixin for SQLAlchemy ORM tables providing explicit serialisation helpers.</p> <p>This interface adds lightweight, deterministic helpers for converting ORM-mapped rows into dictionaries, JSON strings, and stable fingerprints.</p> <p>It is intended for: - debugging and inspection - auditing and reproducibility checks - lightweight export or API layers - content-addressable comparisons</p> <p>No assumptions are made about schema semantics or domain logic.</p>"},{"location":"tables/serialisable_table/#orm_loader.tables.serialisable_table.SerialisableTableInterface.__iter__","title":"<code>__iter__()</code>","text":"<p>Iterate over the ORM instance as <code>(key, value)</code> pairs.</p> <p>This enables lightweight unpacking and interoperability with dictionary-based APIs.</p> <p>Yields:</p> Type Description <code>tuple[str, Any]</code> <p>Column name and value pairs.</p>"},{"location":"tables/serialisable_table/#orm_loader.tables.serialisable_table.SerialisableTableInterface.__json__","title":"<code>__json__()</code>","text":"<p>Return a JSON-serialisable representation of the ORM instance.</p> <p>This hook is provided for compatibility with JSON encoders that check for a <code>__json__</code> method.</p> <p>Returns:</p> Type Description <code>dict[str, Any]</code> <p>A dictionary representation of the ORM row.</p>"},{"location":"tables/serialisable_table/#orm_loader.tables.serialisable_table.SerialisableTableInterface.fingerprint","title":"<code>fingerprint()</code>","text":"<p>Compute a stable fingerprint for the ORM instance.</p> <p>The fingerprint is derived from the JSON serialisation of the row with null values included and is suitable for: - change detection - deduplication - caching - reproducibility checks</p> <p>Returns:</p> Type Description <code>str</code> <p>A SHA-256 hexadecimal digest representing the row content.</p>"},{"location":"tables/serialisable_table/#orm_loader.tables.serialisable_table.SerialisableTableInterface.to_dict","title":"<code>to_dict(*, include_nulls=False, only=None, exclude=None)</code>","text":"<p>Convert the ORM instance into a dictionary.</p> <p>The output is derived directly from the mapped model columns and reflects the current in-memory state of the object.</p> <p>Parameters:</p> Name Type Description Default <code>include_nulls</code> <code>bool</code> <p>Whether to include keys whose values are <code>None</code>. Defaults to <code>False</code>.</p> <code>False</code> <code>only</code> <code>set[str] | None</code> <p>An optional set of column names to include. If provided, all other columns are ignored.</p> <code>None</code> <code>exclude</code> <code>set[str] | None</code> <p>An optional set of column names to exclude.</p> <code>None</code> <p>Returns:</p> Type Description <code>dict[str, Any]</code> <p>A dictionary representation of the ORM row.</p>"},{"location":"tables/serialisable_table/#orm_loader.tables.serialisable_table.SerialisableTableInterface.to_json","title":"<code>to_json(**kwargs)</code>","text":"<p>Serialise the ORM instance to a JSON string.</p> <p>This method delegates to :meth:<code>to_dict</code> and applies a stable, deterministic JSON encoding with sorted keys.</p> <p>Parameters:</p> Name Type Description Default <code>**kwargs</code> <p>Keyword arguments forwarded to :meth:<code>to_dict</code>.</p> <code>{}</code> <p>Returns:</p> Type Description <code>str</code> <p>A JSON representation of the ORM row.</p>"},{"location":"tables/typing/","title":"Typing Protocols","text":"<p>Structural protocols defining the expected interfaces for: - ORM table classes - CSV-loadable tables - Parquet-loadable tables - serialisable row instances</p> <p>Protocols allow infrastructure to remain decoupled from concrete base classes.</p>"},{"location":"tables/typing/#ormtableprotocol","title":"ORMTableProtocol","text":"<p>               Bases: <code>Protocol</code></p> <p>Structural protocol for ORM-mapped table classes.</p> <p>This protocol defines the minimal structural surface expected of SQLAlchemy ORM table classes within <code>orm-loader</code>.</p> <p>It is intentionally lightweight and model-agnostic, focusing on: - core SQLAlchemy table attributes - primary key introspection - column discovery helpers</p> <p>This protocol is used for static typing, runtime checks, and to decouple higher-level infrastructure from concrete base classes.</p>"},{"location":"tables/typing/#csvtableprotocol","title":"CSVTableProtocol","text":"<p>               Bases: <code>ORMTableProtocol</code>, <code>Protocol</code></p> <p>Structural protocol for ORM tables that support CSV-based ingestion.</p> <p>This protocol captures the expected interface for tables that can participate in staged, file-based loading workflows using CSV input.</p> <p>It defines the contract for: - staging table management - loader selection - CSV ingestion and merging semantics</p> <p>No assumptions are made about the underlying database or schema.</p>"},{"location":"tables/typing/#serializedtableprotocol","title":"SerializedTableProtocol","text":"<p>               Bases: <code>Protocol</code></p> <p>Structural protocol for ORM instances that support stable serialisation.</p> <p>This protocol defines the expected interface for ORM row instances that can be converted to dictionaries, JSON strings, and deterministic fingerprints.</p> <p>It is primarily used for typing and interoperability with downstream consumers such as validators, APIs, and audit tooling.</p>"}]}